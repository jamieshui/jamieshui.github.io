<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | 前端知识维基</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/img/logo.svg">
    <meta name="description" content="Jamie的个人前端知识库">
    
    <link rel="preload" href="/assets/css/0.styles.495d9abf.css" as="style"><link rel="preload" href="/assets/js/app.58d5b322.js" as="script"><link rel="preload" href="/assets/js/2.d9f8578e.js" as="script"><link rel="preload" href="/assets/js/28.7e14793f.js" as="script"><link rel="prefetch" href="/assets/js/10.b22ef15b.js"><link rel="prefetch" href="/assets/js/11.369cb489.js"><link rel="prefetch" href="/assets/js/12.ad7e192f.js"><link rel="prefetch" href="/assets/js/13.4535a34a.js"><link rel="prefetch" href="/assets/js/14.648dc886.js"><link rel="prefetch" href="/assets/js/15.d890679a.js"><link rel="prefetch" href="/assets/js/16.e2660027.js"><link rel="prefetch" href="/assets/js/17.f6bfe71e.js"><link rel="prefetch" href="/assets/js/18.25f6959d.js"><link rel="prefetch" href="/assets/js/19.b4911249.js"><link rel="prefetch" href="/assets/js/20.a2e55b45.js"><link rel="prefetch" href="/assets/js/21.0f16212e.js"><link rel="prefetch" href="/assets/js/22.e1e5db6e.js"><link rel="prefetch" href="/assets/js/23.e91ef8e2.js"><link rel="prefetch" href="/assets/js/24.d6c1629f.js"><link rel="prefetch" href="/assets/js/25.67bfb1d5.js"><link rel="prefetch" href="/assets/js/26.239b92f8.js"><link rel="prefetch" href="/assets/js/27.bc849161.js"><link rel="prefetch" href="/assets/js/29.adffb486.js"><link rel="prefetch" href="/assets/js/3.639daa35.js"><link rel="prefetch" href="/assets/js/30.1dce4615.js"><link rel="prefetch" href="/assets/js/31.4c81154b.js"><link rel="prefetch" href="/assets/js/32.bde74a75.js"><link rel="prefetch" href="/assets/js/33.c5ee316d.js"><link rel="prefetch" href="/assets/js/34.c62dfccf.js"><link rel="prefetch" href="/assets/js/35.ea8a9888.js"><link rel="prefetch" href="/assets/js/36.06afa074.js"><link rel="prefetch" href="/assets/js/37.11a91269.js"><link rel="prefetch" href="/assets/js/38.6942e461.js"><link rel="prefetch" href="/assets/js/39.620971a1.js"><link rel="prefetch" href="/assets/js/4.1b609518.js"><link rel="prefetch" href="/assets/js/40.52150e02.js"><link rel="prefetch" href="/assets/js/41.fac14e3f.js"><link rel="prefetch" href="/assets/js/42.36d47a73.js"><link rel="prefetch" href="/assets/js/43.e4fe95fc.js"><link rel="prefetch" href="/assets/js/44.3aa1db93.js"><link rel="prefetch" href="/assets/js/45.49f8538e.js"><link rel="prefetch" href="/assets/js/46.51f81eee.js"><link rel="prefetch" href="/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/assets/js/7.f39602d3.js"><link rel="prefetch" href="/assets/js/8.6340730b.js"><link rel="prefetch" href="/assets/js/9.d08c9a59.js">
    <link rel="stylesheet" href="/assets/css/0.styles.495d9abf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识维基</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础" class="mobile-dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic-computer-courses/computer-networks.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  计算机基础知识
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/01-basic/" class="nav-link">
  基础知识
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/02-data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/03-advanced-algorithm/" class="nav-link">
  进阶算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/04-algorithm-design-concept/" class="nav-link">
  算法设计思想
</a></li></ul></div></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://blog.csdn.net/qq_40642832" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/jamieshui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础" class="mobile-dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic-computer-courses/computer-networks.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  计算机基础知识
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/01-basic/" class="nav-link">
  基础知识
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/02-data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/03-advanced-algorithm/" class="nav-link">
  进阶算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/04-algorithm-design-concept/" class="nav-link">
  算法设计思想
</a></li></ul></div></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://blog.csdn.net/qq_40642832" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/jamieshui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/basic-computer-courses/computer-networks.html" aria-current="page" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#osi七层模型" class="sidebar-link">OSI七层模型</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#http" class="sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#http-1-0-1-1-2-0-区别" class="sidebar-link">HTTP 1.0/1.1/2.0 区别</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#http-常见状态码" class="sidebar-link">HTTP 常见状态码</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#缓存控制策略" class="sidebar-link">缓存控制策略</a></li></ul></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#tcp" class="sidebar-link">TCP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#三次握手" class="sidebar-link">三次握手</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#四次挥手" class="sidebar-link">四次挥手</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#流量控制" class="sidebar-link">流量控制</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#拥塞控制" class="sidebar-link">拥塞控制</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#可靠通信" class="sidebar-link">可靠通信</a></li></ul></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#udp" class="sidebar-link">UDP</a></li><li class="sidebar-sub-header"><a href="/basic-computer-courses/computer-networks.html#websocket" class="sidebar-link">WebSocket</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="osi七层模型"><a href="#osi七层模型" class="header-anchor">#</a> OSI七层模型</h2> <ul><li>OSI（Open System Interconnect），是ISO（国际标准化组织）组织在1985年研究的网络互联模型。</li> <li>该体系结构标准定义了网络互连的七层框架（<strong>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong>）。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.6zs0rsjv9q80.png" alt="image"></p> <ul><li><p>实际上，计算机网络体系结构分为3种：<code>OSI</code>体系结构、<code>TCP</code> / <code>IP</code>体系结构、五层体系结构</p> <blockquote><ul><li><p><code>OSI</code>体系结构：概念清楚 &amp; 理念完整，但复杂 &amp; 不实用</p></li> <li><p><code>TCP</code> / <code>IP</code>体系结构：含了一系列构成互联网基础的网络协议，是<code>Internet</code>的核心协议 &amp; 被广泛应用于局域网 和 广域网</p></li> <li><p>五层体系结构：融合了<code>OSI</code> 与 <code>TCP</code> / <code>IP</code>的体系结构，目的是为了学习 &amp; 讲解计算机原理</p></li></ul></blockquote></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.b9vuh78dzio.png" alt="image"></p> <h2 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h2> <h3 id="http-1-0-1-1-2-0-区别"><a href="#http-1-0-1-1-2-0-区别" class="header-anchor">#</a> HTTP 1.0/1.1/2.0 区别</h3> <table><thead><tr><th>协议版本</th> <th>特点</th></tr></thead> <tbody><tr><td>HTTP 1.0</td> <td>无状态、无连接</td></tr> <tr><td>HTTP 1.1</td> <td>1. 长（持久）连接（即在同一个<code>TCP</code>的连接中可传送多个<code>HTTP</code>请求 &amp; 响应）<br>2. 请求管道化<br>3. 增加缓存处理（新的字段如<code>cache-control</code>）<br>4. 增加<code>Host</code>字段、支持断点传输等（把文件分成几部分）</td></tr> <tr><td>HTTP 2.0</td> <td>1. 二进制分帧<br>2. 多路复用（或连接共享）<br>3. 头部压缩<br>4. 服务器推送</td></tr></tbody></table> <p>*参考资料：<a href="https://blog.csdn.net/qq_36183935/article/details/81156225?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control" target="_blank" rel="noopener noreferrer">《HTTP1.0、HTTP1.1、HTTP2.0的关系和区别》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="http-常见状态码"><a href="#http-常见状态码" class="header-anchor">#</a> HTTP 常见状态码</h3> <ul><li>一般 1XX 代表<strong>服务器接收到请求</strong>、2XX 代表<strong>成功</strong>、3XX 代表<strong>重定向</strong>、4XX 代表<strong>客户端错误</strong>、5XX 代表<strong>服务器端错误</strong>。</li></ul> <table><thead><tr><th>状态码</th> <th>描述</th></tr></thead> <tbody><tr><td>101</td> <td>切换请求协议，从 HTTP 切换到 WebSocket</td></tr> <tr><td>200</td> <td>请求成功，有响应体</td></tr> <tr><td>301</td> <td>永久重定向：会缓存</td></tr> <tr><td>302</td> <td>临时重定向：不会缓存</td></tr> <tr><td>304</td> <td><strong>协商缓存命中</strong></td></tr> <tr><td>400</td> <td>请求错误</td></tr> <tr><td>403</td> <td>服务器禁止访问</td></tr> <tr><td>404</td> <td>资源未找到</td></tr> <tr><td>500</td> <td>服务器端错误</td></tr> <tr><td>503</td> <td>服务器繁忙</td></tr></tbody></table> <h3 id="缓存控制策略"><a href="#缓存控制策略" class="header-anchor">#</a> 缓存控制策略</h3> <ul><li>HTTP 缓存又分为<strong>强缓存</strong>和<strong>协商缓存</strong>：
<ul><li>首先通过 <code>Cache-Control</code> 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存；</li> <li>如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 这些条件请求字段检查资源是否更新：
<ul><li>若资源更新，那么返回资源和 <strong><code>200</code></strong> 状态码；</li> <li>若资源未更新，那么告诉浏览器直接使用缓存获取资源，并返回**<code>304</code>**状态码。</li></ul></li></ul></li></ul> <h2 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h2> <ul><li><code>Transmission Control Protocol</code>，即 传输控制协议。</li></ul> <blockquote><ol><li>属于 传输层通信协议</li> <li>基于<code>TCP</code>的应用层协议有<code>HTTP</code>、<code>SMTP</code>、<code>FTP</code>、<code>Telnet</code> 和 <code>POP3</code></li></ol></blockquote> <h3 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h3> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3.lhcokjn9xb4.gif" alt="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3"></p> <h4 id="三次握手的步骤"><a href="#三次握手的步骤" class="header-anchor">#</a> 三次握手的步骤</h4> <blockquote><p><strong>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p> <p>TCP 服务器进程先创建传输控制块 TCB ，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态；</p></blockquote> <ol><li>TCP 客户进程先创建传输控制块 TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li> <li>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li> <li>TCP 客户进程收到确认后，还要向服务器给出确认。确认报文中 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态，当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li></ol> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.15qkrf7nijc0.png" alt="image"></p> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.hhsi5d8zrww.png" alt="image"></p> <h4 id="三次握手的作用"><a href="#三次握手的作用" class="header-anchor">#</a> 三次握手的作用</h4> <ul><li>确认双方的接收及发送能力是否正常。</li> <li>指定自己的初始化序列号，为后期可靠传送做准备。</li> <li>对于 HTTPS 协议，该过程还会进行数字证书的验证及加密密钥的生成。</li></ul> <h4 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="header-anchor">#</a> 为什么不是两次握手？</h4> <ul><li>差别在于最后客户端对服务器的确认。防止已经失效的连接报文请求突然传送至服务器，从而产生错误（服务器端因接收了<strong>早已失效的连接请求报文</strong>，从而一直等待客户端请求，最终导致<strong>形成死锁、浪费资源</strong>）。</li></ul> <blockquote><p>例如：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留时间较长。此时由于客户端迟迟没有收到 ACK 确认报文，以为服务器没有收到，会重新发送，但是网络通畅时之前的报文又传送过来了，于是客户端和服务器会建立两次连接，造成不必要的错误和资源浪费。</p> <p>而若是三次握手，即使失效报文传至服务器，服务器回复 ACK 报文，客户端也不会再次确认，于是连接不会再次建立。</p></blockquote> <h4 id="为什么不是四次握手"><a href="#为什么不是四次握手" class="header-anchor">#</a> 为什么不是四次握手？</h4> <ul><li>因为服务器向客户端发送 ACK 报文和 SYN 报文的流程可以优化为一次握手。</li></ul> <h3 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h3> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1.49487cmfl8a0.gif" alt="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1"></p> <h4 id="四次挥手的步骤"><a href="#四次挥手的步骤" class="header-anchor">#</a> 四次挥手的步骤</h4> <blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote> <ol><li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 <strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></p></li> <li><p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向释放了 TCP 连接，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p> <blockquote><p>客户端收到服务器的确认请求后，此时客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p></blockquote></li> <li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于处于半关闭状态时，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p></li> <li><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 <strong>2*MSL</strong>（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p> <blockquote><p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p></blockquote></li></ol> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.eebwd5s7zmw.png" alt="image"></p> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.3vcr93r4mlm0.png" alt="image"></p> <h4 id="为什么不是三次挥手"><a href="#为什么不是三次挥手" class="header-anchor">#</a> 为什么不是三次挥手？</h4> <ul><li><p>服务端在接收到<code>FIN</code>， 往往不会立即返回<code>FIN</code>，必须等到服务端所有数据都发送完毕了，才能发<code>FIN</code>。因此先发一个<code>ACK</code>表示已经收到客户端的<code>FIN</code>，延迟一段时间才发<code>FIN</code>。这就造成了四次挥手。</p></li> <li><p>如果是三次挥手，等于说服务端将<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为<code>FIN</code>没有到达客户端，从而让客户端不断的重发<code>FIN</code>。</p></li></ul> <h4 id="为什么需要等待-2msl-maximum-segement-lifetime"><a href="#为什么需要等待-2msl-maximum-segement-lifetime" class="header-anchor">#</a> 为什么需要等待 2MSL（Maximum Segement Lifetime）？</h4> <ul><li>假设不等待，如果服务端还有很多数据包要给客户端发，而此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱。</li> <li>等待<code>2MSL</code>的意义：
<ul><li>1 个<code>MSL</code>确保四次挥手中客户端最后的<code>ACK</code>报文最终能达到服务器端。</li> <li>1 个<code>MSL</code>确保服务器端没有收到<code>ACK</code>后重传的<code>FIN</code>报文可以到达。</li></ul></li></ul> <h3 id="流量控制"><a href="#流量控制" class="header-anchor">#</a> 流量控制</h3> <ul><li>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。</li> <li>接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</li></ul> <h3 id="拥塞控制"><a href="#拥塞控制" class="header-anchor">#</a> 拥塞控制</h3> <ul><li>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</li> <li>TCP 的拥塞控制主要使用了四个机制，分别是<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快速重传</strong>和<strong>快速恢复</strong>。
<ul><li>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT （Round Trip Time，网络往返时间）时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。</li> <li>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。这样将窗口的增长速率由指数增长，变为加法线性增长。</li> <li>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</li> <li>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</li></ul></li> <li>TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四种机制来达到拥塞控制的目的。</li></ul> <h3 id="可靠通信"><a href="#可靠通信" class="header-anchor">#</a> 可靠通信</h3> <h4 id="tcp如何保证数据的可靠传输"><a href="#tcp如何保证数据的可靠传输" class="header-anchor">#</a> TCP如何保证数据的可靠传输？</h4> <p><strong>（1）校验和</strong></p> <p>数据传输过程中，发送的数据段都会当成一个16位的整数，将整数加起来得到校验和。发送方在发送数据前计算校验和，接收方收到数据后对数据使用同样方式计算求出校验和，与发送方的进行比对。</p> <p><strong>（2）确认应答和序列号</strong></p> <p>TCP传输时对每个字节的数据进行编号，即序列号。同时每次接收方收到数据后，都会对传输方发送 ACK 确认应答。</p> <p><strong>（3）超时重传</strong></p> <p>发送数据后等待一段时间没有收到 ACK 报文，将对刚才发送的数据进行重新发送。</p> <p><strong>（4）连接管理</strong></p> <p>三次握手和四次挥手。</p> <p><strong>（5）流量控制</strong></p> <p>TCP根据接收端对数据的处理能力，决定发送方的发送速度。</p> <p><strong>（6）拥塞控制</strong></p> <p>TCP通过维护拥塞窗口实现拥塞控制，窗口会根据当前拥塞情况增大或缩小。</p> <h2 id="udp"><a href="#udp" class="header-anchor">#</a> UDP</h2> <ul><li><code>User Datagram Protocol</code>，即 用户数据报协议。</li></ul> <blockquote><ol><li>属于 传输层通信协议</li> <li>基于<code>UDP</code>的应用层协议有 <code>TFTP</code>、<code>SNMP</code> 与 <code>DNS</code></li></ol></blockquote> <ul><li><p>特点：无连接的、不可靠的、面向报文、无拥塞控制。</p> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.56z43hjx4k80.png" alt="image"></p></li></ul> <h2 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h2> <ul><li>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。</li> <li>使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。</li> <li>WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.58d5b322.js" defer></script><script src="/assets/js/2.d9f8578e.js" defer></script><script src="/assets/js/28.7e14793f.js" defer></script>
  </body>
</html>
