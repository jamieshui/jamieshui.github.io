(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{443:function(t,a,e){"use strict";e.r(a);var r=e(56),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" CSS")]),t._v(" "),e("h3",{attrs:{id:"常见的水平垂直方式有几种"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的水平垂直方式有几种"}},[t._v("#")]),t._v(" 常见的水平垂直方式有几种？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/* 1. 利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，\n然后再通过 translate 来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。*/\n\n/* 2. 利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，\n由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。 */\n\n/* 3. 使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对齐，\n然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的问题，该方法在移动端用的较多。 */\n\n/* 4. 父元素设置了flex布局，只需要给子元素加上 `margin:auto;` 就可以实现水平垂直居中布局。 */\n")])])]),e("h3",{attrs:{id:"标准盒模型和怪异盒模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标准盒模型和怪异盒模型"}},[t._v("#")]),t._v(" 标准盒模型和怪异盒模型？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[e("p",[t._v("盒模型都是由四个部分组成的，分别是margin、border、padding和content。")])]),t._v(" "),e("li",[e("p",[t._v("标准盒模型和怪异盒模型（即IE盒模型）的区别在于设置width和height时，所对应的范围不同。")]),t._v(" "),e("p",[t._v("标准盒模型的width和height属性的范围只包含了content，而怪异盒模型的width和height属性的范围包含了border、padding和content。")])]),t._v(" "),e("li",[e("p",[t._v("一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。")]),t._v(" "),e("blockquote",[e("p",[t._v("在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。")])])])])])]),t._v(" "),e("h3",{attrs:{id:"flex常见的属性-flex-1代表什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex常见的属性-flex-1代表什么"}},[t._v("#")]),t._v(" Flex常见的属性  flex: 1代表什么？")]),t._v(" "),e("ul",[e("li",[t._v("flex有三个值，分别为0, 1 , auto; 是 flex-grow，flex-shrink ，flex-basis三个值合并的简写")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("flex-grow")]),t._v(" "),e("th",[t._v("flex-shrink")]),t._v(" "),e("th",[t._v("flex-basis")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("flex: 1")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("0%")])]),t._v(" "),e("tr",[e("td",[t._v("flex: 0")]),t._v(" "),e("td",[t._v("0")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("0%")])]),t._v(" "),e("tr",[e("td",[t._v("flex: auto")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("auto")])])])]),t._v(" "),e("h3",{attrs:{id:"rem你是怎么做适配的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rem你是怎么做适配的"}},[t._v("#")]),t._v(" Rem你是怎么做适配的？")]),t._v(" "),e("h3",{attrs:{id:"媒体查询是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#媒体查询是什么"}},[t._v("#")]),t._v(" 媒体查询是什么？")]),t._v(" "),e("ul",[e("li",[t._v("CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。")])]),t._v(" "),e("h3",{attrs:{id:"说一下你对盒模型的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下你对盒模型的理解"}},[t._v("#")]),t._v(" 说一下你对盒模型的理解？")]),t._v(" "),e("ul",[e("li",[t._v("可以从标准盒模型和怪异盒模型的角度出发。")])]),t._v(" "),e("h2",{attrs:{id:"javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[t._v("#")]),t._v(" JavaScript")]),t._v(" "),e("h3",{attrs:{id:"什么是浅拷贝和深拷贝-以及怎么实现浅拷贝和深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是浅拷贝和深拷贝-以及怎么实现浅拷贝和深拷贝"}},[t._v("#")]),t._v(" 什么是浅拷贝和深拷贝？以及怎么实现浅拷贝和深拷贝？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以"),e("strong",[t._v("如果其中一个对象改变了这个地址，就会影响到另一个对象")]),t._v("。")]),t._v(" "),e("p",[t._v("深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且"),e("strong",[t._v("修改新对象不会影响原对象")]),t._v("。")])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 实现浅拷贝和深拷贝\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"什么是原型-什么是原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型-什么是原型链"}},[t._v("#")]),t._v(" 什么是原型？什么是原型链？")]),t._v(" "),e("ul",[e("li",[t._v("原型：在 JS 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 "),e("code",[t._v("prototype")]),t._v(" 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 "),e("code",[t._v("prototype")]),t._v(" 属性对应的值，在 ES5 中这个指针被称为对象的"),e("strong",[t._v("原型")]),t._v("。")]),t._v(" "),e("li",[t._v("原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是"),e("strong",[t._v("原型链")]),t._v("的概念。原型链的尽头一般来说都是 "),e("code",[t._v("Object.prototype")]),t._v(" 所以这就是我们新建的对象为什么能够使用 "),e("code",[t._v("toString()")]),t._v(" 等方法的原因。")])]),t._v(" "),e("h3",{attrs:{id:"箭头函数和普通函数有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数和普通函数有什么区别"}},[t._v("#")]),t._v(" 箭头函数和普通函数有什么区别？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("箭头函数比普通函数更加简洁")]),t._v(" "),e("li",[t._v("箭头函数没有自己的this，它只会从自己的作用域链的上一层继承this")]),t._v(" "),e("li",[t._v("call()、apply()、bind()等方法不能改变箭头函数中的this指向 （即无法传递this）")]),t._v(" "),e("li",[t._v("箭头函数没有自己的arguments，而是用剩余参数...rest来替代")]),t._v(" "),e("li",[t._v("箭头函数没有prototype")]),t._v(" "),e("li",[t._v("箭头函数不能用作构造函数，不能使用new关键字")])])])]),t._v(" "),e("h3",{attrs:{id:"new操作符做了什么事情"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new操作符做了什么事情"}},[t._v("#")]),t._v(" New操作符做了什么事情？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("首先创建了一个新对象（即实例）")]),t._v(" "),e("li",[t._v("设置原型链，将新对象的隐式原型"),e("code",[t._v("__proto__")]),t._v("指向对应构造函数的显式原型"),e("code",[t._v("prototype")])]),t._v(" "),e("li",[t._v("让构造函数的this指针指向这个新对象，并执行构造函数的代码（为这个新对象添加属性）")]),t._v(" "),e("li",[t._v("判断构造函数的返回值类型，如果是值类型，返回创建的对象；如果是引用类型，则返回这个引用类型的对象。")])])])]),t._v(" "),e("h3",{attrs:{id:"说一下事件循环eventloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下事件循环eventloop"}},[t._v("#")]),t._v(" 说一下事件循环eventloop？")]),t._v(" "),e("ul",[e("li",[t._v("事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。")])]),t._v(" "),e("h3",{attrs:{id:"什么是闭包-闭包的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包-闭包的作用是什么"}},[t._v("#")]),t._v(" 什么是闭包？闭包的作用是什么？")]),t._v(" "),e("ul",[e("li",[t._v("闭包：指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。")]),t._v(" "),e("li",[t._v("作用：\n"),e("ol",[e("li",[t._v("使我们在函数外部能够访问到函数内部的变量，即隐藏数据只提供API。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。")]),t._v(" "),e("li",[t._v("使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收，既可以长久的保存变量又不会造成全局污染。")])])])]),t._v(" "),e("h3",{attrs:{id:"promise是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise是什么"}},[t._v("#")]),t._v(" Promise是什么?")]),t._v(" "),e("ul",[e("li",[t._v("是异步编程的一种解决方案。简单说它就像一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，可以从改对象获取异步操作的消息。它可以解决"),e("strong",[t._v("回调地狱")]),t._v("的问题，也就是异步深层嵌套问题。Promise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造Promise实例后，它会立即执行。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们\n可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。")]),t._v(" "),e("li",[t._v("手写Promise")])]),t._v(" "),e("h3",{attrs:{id:"set和map有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set和map有什么区别"}},[t._v("#")]),t._v(" Set和Map有什么区别？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("Map是键值对，Set是值的集合")]),t._v(" "),e("li",[t._v("Map可以通过get方法获取值，而set不能因为它只有值")]),t._v(" "),e("li",[t._v("都能通过迭代器进行for...of 遍历")]),t._v(" "),e("li",[t._v("Set的值是唯一的，可以做数组去重，而Map由于没有格式限制，可以做数据存储")])])])]),t._v(" "),e("h3",{attrs:{id:"map和foreach有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map和foreach有什么区别"}},[t._v("#")]),t._v(" Map和forEach有什么区别？")]),t._v(" "),e("ul",[e("li",[t._v("map会返回一个新的数组，不会改变原来的数组，forEach不会返回新数组，允许对原数组进行修改。")]),t._v(" "),e("li",[t._v("map方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值。")]),t._v(" "),e("li",[t._v("forEach方法会针对每一个元素执行提供得函数，该方法没有返回值，是否会改变原数组取决与数组元素的类型是基本类型还是引用类型。")])]),t._v(" "),e("h3",{attrs:{id:"computed和watch有什么区别-以及它们的运用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch有什么区别-以及它们的运用场景"}},[t._v("#")]),t._v(" computed和watch有什么区别？以及它们的运用场景？")]),t._v(" "),e("ul",[e("li",[t._v("区别：\n"),e("ul",[e("li",[e("ol",[e("li",[t._v("功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。")]),t._v(" "),e("li",[t._v("是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。")]),t._v(" "),e("li",[t._v("是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。")]),t._v(" "),e("li",[t._v("computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）")])])])])]),t._v(" "),e("li",[t._v("运用场景：\n"),e("ul",[e("li",[t._v("computed：当一个属性受多个属性影响的时候，比如当需要进行数值计算，并且依赖与其它数据时，应该使用computed，因为可以利用computed的缓存属性，避免每次获取值时都要重新计算。使用computed——购物车商品结算。")]),t._v(" "),e("li",[t._v("watch：当一条数据影响多条数据的时候，比如当需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许执行异步操作（访问一个API），限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。使用watch——搜索框.")])])])]),t._v(" "),e("h3",{attrs:{id:"es6常见的语法你知道哪一些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6常见的语法你知道哪一些"}},[t._v("#")]),t._v(" ES6常见的语法你知道哪一些？")]),t._v(" "),e("ul",[e("li",[t._v("块级作用域（let、const）、模版字符串、解构赋值、箭头函数、函数默认参数、剩余参数&扩展运算符、对象新增方法——Object.assign()、Set和Map数据结构")])]),t._v(" "),e("h3",{attrs:{id:"说一下防抖和节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下防抖和节流"}},[t._v("#")]),t._v(" 说一下防抖和节流？")]),t._v(" "),e("ul",[e("li",[t._v("防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。比如有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。")]),t._v(" "),e("li",[t._v("节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。比如懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。")]),t._v(" "),e("li",[t._v("手写防抖和节流")])]),t._v(" "),e("h3",{attrs:{id:"说一下slice-splice-split-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下slice-splice-split-的区别"}},[t._v("#")]),t._v(" 说一下slice splice split 的区别？")]),t._v(" "),e("ul",[e("li",[t._v("slice对数组进行部分截取，并且返回一个新的数组，不改变原来的数组")]),t._v(" "),e("li",[t._v("splice会改变原数组，对原数组进行增删改查")]),t._v(" "),e("li",[t._v("split根据特定的字符串切分成数组")])]),t._v(" "),e("h3",{attrs:{id:"说一下怎么把类数组转换为数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下怎么把类数组转换为数组"}},[t._v("#")]),t._v(" 说一下怎么把类数组转换为数组？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("通过 call 调用数组的 slice 方法来实现转换："),e("code",[t._v("Array.prototype.slice.call(arrayLike);")])]),t._v(" "),e("li",[t._v("通过 Array.from 方法来实现转换："),e("code",[t._v("Array.from(arrayLike);")])]),t._v(" "),e("li",[t._v("通过展开（扩展）运算符："),e("code",[t._v("[...arrayLike]")])])])])]),t._v(" "),e("h3",{attrs:{id:"说一下数组如何去重-你有几种方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下数组如何去重-你有几种方法"}},[t._v("#")]),t._v(" 说一下数组如何去重，你有几种方法？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("Set集合")]),t._v(" "),e("li",[t._v("Map字典")]),t._v(" "),e("li",[t._v("indexOf() / includes()")]),t._v(" "),e("li",[t._v("filter+indexOf()")])])])]),t._v(" "),e("h3",{attrs:{id:"说一下怎么取出数组中出现最多的元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下怎么取出数组中出现最多的元素"}},[t._v("#")]),t._v(" 说一下怎么取出数组中出现最多的元素？")]),t._v(" "),e("ul",[e("li",[t._v("map+sort+filter")])]),t._v(" "),e("h3",{attrs:{id:"说一下json-stringify在深拷贝方面有什么缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下json-stringify在深拷贝方面有什么缺点"}},[t._v("#")]),t._v(" 说一下JSON.stringify在深拷贝方面有什么缺点？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式")]),t._v(" "),e("li",[t._v("如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；")]),t._v(" "),e("li",[t._v("如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失")]),t._v(" "),e("li",[t._v("如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null")]),t._v(" "),e("li",[t._v("JSON.stringify()只能序列化对象的可枚举的自有属性，如果obj中的对象是由new出来的构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor初始化构造器；")]),t._v(" "),e("li",[t._v("如果对象中存在循环引用的情况也无法正确实现深拷贝；")])])])]),t._v(" "),e("h3",{attrs:{id:"说一下for-in-和-for-of的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下for-in-和-for-of的区别"}},[t._v("#")]),t._v(" 说一下for...in 和 for...of的区别？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("for...in会遍历对象的整个原型链，性能非常差不推荐使用，而for...of只遍历当前对象不会遍历原型链。")]),t._v(" "),e("li",[t._v("for...in获取的是对象的键名；for...of遍历获取的是对象的键值。")]),t._v(" "),e("li",[t._v("for...in循环主要是为了遍历对象而生,不适用遍历数组; for....of循环可以用来遍历数组、类数组对象、字符串、Set、Map以及Generator对象。")])])])]),t._v(" "),e("h2",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),e("h3",{attrs:{id:"说一下data为什么是一个函数而不是一个对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下data为什么是一个函数而不是一个对象"}},[t._v("#")]),t._v(" 说一下data为什么是一个函数而不是一个对象？")]),t._v(" "),e("ul",[e("li",[t._v("JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。")])]),t._v(" "),e("h3",{attrs:{id:"vue实现双向数据绑定原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue实现双向数据绑定原理是什么"}},[t._v("#")]),t._v(" vue实现双向数据绑定原理是什么？")]),t._v(" "),e("ul",[e("li",[t._v("vue.js 是采用"),e("strong",[t._v("数据劫持")]),t._v("结合"),e("strong",[t._v("发布者-订阅者模式的")]),t._v("方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n"),e("ul",[e("li",[t._v("vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。首先我们通过"),e("code",[t._v("Object.defineProperty()")]),t._v("方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，另一种是作为文本绑定，在对模板引擎进行解析的过程中。如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。")])])]),t._v(" "),e("li",[t._v("手写双向数据绑定原理")])]),t._v(" "),e("h3",{attrs:{id:"v-model语法糖是怎么实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-model语法糖是怎么实现的"}},[t._v("#")]),t._v(" v-model语法糖是怎么实现的？")]),t._v(" "),e("h3",{attrs:{id:"vuex有哪些基本属性-为什么-vuex-的-mutation-中不能做异步操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex有哪些基本属性-为什么-vuex-的-mutation-中不能做异步操作"}},[t._v("#")]),t._v(" Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?")]),t._v(" "),e("h3",{attrs:{id:"vue的生命周期是什么-每个钩子里面具体做了什么事情"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期是什么-每个钩子里面具体做了什么事情"}},[t._v("#")]),t._v(" Vue的生命周期是什么？每个钩子里面具体做了什么事情？")]),t._v(" "),e("h3",{attrs:{id:"组件之间的传值有几种方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件之间的传值有几种方式"}},[t._v("#")]),t._v(" 组件之间的传值有几种方式？")]),t._v(" "),e("h3",{attrs:{id:"eventbus具体是怎么实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventbus具体是怎么实现的"}},[t._v("#")]),t._v(" Eventbus具体是怎么实现的？")]),t._v(" "),e("h3",{attrs:{id:"父组件到子组件更新的方式是什么样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父组件到子组件更新的方式是什么样的"}},[t._v("#")]),t._v(" 父组件到子组件更新的方式是什么样的？")]),t._v(" "),e("h3",{attrs:{id:"nexttick-是干嘛的-你一般拿它做什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-是干嘛的-你一般拿它做什么"}},[t._v("#")]),t._v(" $nexttick 是干嘛的？你一般拿它做什么？")]),t._v(" "),e("h3",{attrs:{id:"keepalive是什么-里面有哪些钩子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keepalive是什么-里面有哪些钩子"}},[t._v("#")]),t._v(" keepalive是什么？里面有哪些钩子？")]),t._v(" "),e("h3",{attrs:{id:"vue的父子组件生命周期钩子函数执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的父子组件生命周期钩子函数执行顺序"}},[t._v("#")]),t._v(" Vue的父子组件生命周期钩子函数执行顺序？")]),t._v(" "),e("h3",{attrs:{id:"说一下vue3-0你了解多少"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下vue3-0你了解多少"}},[t._v("#")]),t._v(" 说一下vue3.0你了解多少？")]),t._v(" "),e("h2",{attrs:{id:"其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),e("h3",{attrs:{id:"路由原理-hash和history有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由原理-hash和history有什么区别"}},[t._v("#")]),t._v(" 路由原理：Hash和history有什么区别？")]),t._v(" "),e("h3",{attrs:{id:"localstorage、sessionstorage、cookies有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#localstorage、sessionstorage、cookies有什么区别"}},[t._v("#")]),t._v(" localStorage、sessionStorage、cookies有什么区别?")]),t._v(" "),e("h3",{attrs:{id:"loader和plugin有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader和plugin有什么区别"}},[t._v("#")]),t._v(" Loader和Plugin有什么区别？")]),t._v(" "),e("h3",{attrs:{id:"在地址栏里输入一个地址回车会发生哪些事情"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在地址栏里输入一个地址回车会发生哪些事情"}},[t._v("#")]),t._v(" 在地址栏里输入一个地址回车会发生哪些事情？")]),t._v(" "),e("h3",{attrs:{id:"udp和tcp有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#udp和tcp有什么区别"}},[t._v("#")]),t._v(" UDP和TCP有什么区别？")]),t._v(" "),e("h3",{attrs:{id:"项目中常用的性能优化方式有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目中常用的性能优化方式有哪些"}},[t._v("#")]),t._v(" 项目中常用的性能优化方式有哪些？")]),t._v(" "),e("h3",{attrs:{id:"插槽是什么-怎么使用的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插槽是什么-怎么使用的"}},[t._v("#")]),t._v(" 插槽是什么？怎么使用的？")]),t._v(" "),e("h3",{attrs:{id:"自定义指令你是怎么用的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令你是怎么用的"}},[t._v("#")]),t._v(" 自定义指令你是怎么用的？")]),t._v(" "),e("h3",{attrs:{id:"重绘和重排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘和重排"}},[t._v("#")]),t._v(" 重绘和重排？")]),t._v(" "),e("h3",{attrs:{id:"浏览器的性能监控你是怎么做的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的性能监控你是怎么做的"}},[t._v("#")]),t._v(" 浏览器的性能监控你是怎么做的？")]),t._v(" "),e("h3",{attrs:{id:"diff算法是什么-key-index-为什么不常用数组的下标作为index-加了它有什么好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff算法是什么-key-index-为什么不常用数组的下标作为index-加了它有什么好处"}},[t._v("#")]),t._v(" Diff算法是什么  ：key = index 为什么不常用数组的下标作为index  加了它有什么好处？")]),t._v(" "),e("h3",{attrs:{id:"虚拟列表你是怎么实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表你是怎么实现的"}},[t._v("#")]),t._v(" 虚拟列表你是怎么实现的？")]),t._v(" "),e("h3",{attrs:{id:"哪些情况会导致内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哪些情况会导致内存泄漏"}},[t._v("#")]),t._v(" 哪些情况会导致内存泄漏？")]),t._v(" "),e("h3",{attrs:{id:"说一下常见的检测数据类型的几种方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下常见的检测数据类型的几种方式"}},[t._v("#")]),t._v(" 说一下常见的检测数据类型的几种方式？")]),t._v(" "),e("h3",{attrs:{id:"说一下类组件和函数组件的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下类组件和函数组件的区别"}},[t._v("#")]),t._v(" 说一下类组件和函数组件的区别？")]),t._v(" "),e("h3",{attrs:{id:"说一下proxy-它有什么优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下proxy-它有什么优点"}},[t._v("#")]),t._v(" 说一下proxy  它有什么优点？")]),t._v(" "),e("h3",{attrs:{id:"说一下bfc-bfc有什么优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下bfc-bfc有什么优缺点"}},[t._v("#")]),t._v(" 说一下bfc bfc有什么优缺点？")]),t._v(" "),e("h3",{attrs:{id:"说一下spa单页面有什么优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下spa单页面有什么优缺点"}},[t._v("#")]),t._v(" 说一下SPA单页面有什么优缺点？")]),t._v(" "),e("h3",{attrs:{id:"说一下前端登录的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下前端登录的流程"}},[t._v("#")]),t._v(" 说一下前端登录的流程？")]),t._v(" "),e("h3",{attrs:{id:"说一下前端权限管理怎么实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下前端权限管理怎么实现"}},[t._v("#")]),t._v(" 说一下前端权限管理怎么实现？")]),t._v(" "),e("h3",{attrs:{id:"说一下购物车的逻辑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下购物车的逻辑"}},[t._v("#")]),t._v(" 说一下购物车的逻辑？")]),t._v(" "),e("h3",{attrs:{id:"说一下http和https协议的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下http和https协议的区别"}},[t._v("#")]),t._v(" 说一下HTTP和HTTPS协议的区别？")]),t._v(" "),e("h3",{attrs:{id:"说一下常见的http状态码-说一下状态码是302和304是什么意思-你在项目中出现过么-你是怎么解决的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下常见的http状态码-说一下状态码是302和304是什么意思-你在项目中出现过么-你是怎么解决的"}},[t._v("#")]),t._v(" 说一下常见的HTTP状态码？说一下状态码是302和304是什么意思？你在项目中出现过么？你是怎么解决的？")]),t._v(" "),e("h3",{attrs:{id:"说一下常见的git操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下常见的git操作"}},[t._v("#")]),t._v(" 说一下常见的git操作")]),t._v(" "),e("h3",{attrs:{id:"首屏性能优化你是怎么做的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首屏性能优化你是怎么做的"}},[t._v("#")]),t._v(" 首屏性能优化你是怎么做的？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("使用webpack进行代码分隔，使用时才加载")]),t._v(" "),e("li",[t._v("浏览器缓存（对DOM查询进行缓存）")]),t._v(" "),e("li",[t._v("懒加载（图片懒加载，上滑加载更多）")]),t._v(" "),e("li",[t._v("CDN")])])])]),t._v(" "),e("h3",{attrs:{id:"怎么解决白屏问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么解决白屏问题"}},[t._v("#")]),t._v(" 怎么解决白屏问题？")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("加loading")]),t._v(" "),e("li",[t._v("骨架屏")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);