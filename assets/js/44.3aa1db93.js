(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{438:function(t,v,s){"use strict";s.r(v);var a=s(56),_=Object(a.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"var-let-const-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#var-let-const-区别"}},[t._v("#")]),t._v(" var/let/const 区别")]),t._v(" "),s("ol",[s("li",[t._v("var 声明的变量是存在"),s("strong",[t._v("变量提升")]),t._v("的，let、const 声明的变量不存在变量提升。")]),t._v(" "),s("li",[t._v("在同一作用域下 var 可以重复声明，let、const不可以重复声明。")]),t._v(" "),s("li",[t._v("var 声明的变量不存在"),s("strong",[t._v("块级作用域")]),t._v("，let、const声明的变量存在块级作用域。")]),t._v(" "),s("li",[t._v("var 和 let 可以重新赋值，const 声明的是一个常量，const 声明的变量必须要进行初始化，不能够重新赋值。")]),t._v(" "),s("li",[t._v("var 声明的变量不存在"),s("strong",[t._v("暂时性死区")]),t._v("，let、const声明的变量存在暂时性死区。")])]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("变量提升")]),t._v("：代码在未定义之前可以使用且不会报错。\n"),s("strong",[t._v("块级作用域")]),t._v("：ES6新增内容。在局部作用域（函数作用域、块级作用域）中访问一个变量，如果这个作用域不存在这个变量，那么根据作用域链查找的原则，会一层层向上查找，直到找到最顶层作用域（全局作用域）为止，如果还找不到，就会报错"),s("code",[t._v("xxx is not defined")]),t._v("。\n"),s("strong",[t._v("暂时性死区")]),t._v("：在变量声明之前，任何的地方都不能去提前使用，一旦使用就会报错，那么这之前的这些代码，对于这个变量来说就是暂时性死区。")])]),t._v(" "),s("h2",{attrs:{id:"es6运算符-剩余运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6运算符-剩余运算符"}},[t._v("#")]),t._v(" ES6运算符——剩余运算符")]),t._v(" "),s("ul",[s("li",[t._v("当函数参数个数不确定时，用 ...rest 运算符。")])]),t._v(" "),s("h2",{attrs:{id:"解决class的this指向问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决class的this指向问题"}},[t._v("#")]),t._v(" 解决class的this指向问题")]),t._v(" "),s("ul",[s("li",[t._v("一般会用箭头函数，"),s("code",[t._v("bind")]),t._v("或者"),s("code",[t._v("proxy")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"call-apply-bind-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind-区别"}},[t._v("#")]),t._v(" call/apply/bind 区别")]),t._v(" "),s("ul",[s("li",[t._v("call、apply和bind都可以改变函数体内部this的指向，但是bind和call/apply有一个很重要的区别：一个函数被call/apply的时候，会立即执行函数，但是bind会创建一个新函数，不会立即执行。")])]),t._v(" "),s("h2",{attrs:{id:"异步任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步任务"}},[t._v("#")]),t._v(" 异步任务")]),t._v(" "),s("ul",[s("li",[t._v("不同的异步任务被分为两类：微任务(micro task)和宏任务(macro task)。")]),t._v(" "),s("li",[s("code",[t._v("setTimeout()")]),t._v("属于宏任务")]),t._v(" "),s("li",[s("code",[t._v("promise.then()")]),t._v("属于微任务")]),t._v(" "),s("li",[t._v("当前执行栈执行完毕后会立刻先处理所有"),s("strong",[t._v("微任务")]),t._v("队列中的事件，然后再去"),s("strong",[t._v("宏任务")]),t._v("队列中取出一个事件。同一次事件循环中，"),s("strong",[t._v("微任务永远在宏任务之前执行")]),t._v("。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);