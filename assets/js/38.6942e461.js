(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{437:function(_,v,t){"use strict";t.r(v);var r=t(56),s=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"计算机网络面试常考知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络面试常考知识点"}},[_._v("#")]),_._v(" 计算机网络面试常考知识点")]),_._v(" "),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[_._v("#")]),_._v(" 目录")]),_._v(" "),t("h3",{attrs:{id:"说说-tcp-三次握手的过程-为什么是三次而不是两次、四次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说-tcp-三次握手的过程-为什么是三次而不是两次、四次"}},[_._v("#")]),_._v(" 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.hhsi5d8zrww.png",alt:"image"}})]),_._v(" "),t("h4",{attrs:{id:"三次握手的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的过程"}},[_._v("#")]),_._v(" 三次握手的过程")]),_._v(" "),t("p",[_._v("从最开始双方都处于"),t("code",[_._v("CLOSED")]),_._v("状态。然后服务端开始监听某个端口，进入了"),t("code",[_._v("LISTEN")]),_._v("状态。")]),_._v(" "),t("ol",[t("li",[_._v("客户端主动发起连接，发送"),t("code",[_._v("SYN")]),_._v(" , 自己变成了"),t("code",[_._v("SYN-SENT")]),_._v("状态。")]),_._v(" "),t("li",[_._v("服务端接收到，返回"),t("code",[_._v("SYN")]),_._v("和"),t("code",[_._v("ACK")]),_._v("(对应客户端发来的SYN)，自己变成了"),t("code",[_._v("SYN-REVD")]),_._v("。")]),_._v(" "),t("li",[_._v("客户端再发送"),t("code",[_._v("ACK")]),_._v("给服务端，自己变成了"),t("code",[_._v("ESTABLISHED")]),_._v("状态；服务端收到"),t("code",[_._v("ACK")]),_._v("之后，也变成了"),t("code",[_._v("ESTABLISHED")]),_._v("状态。")])]),_._v(" "),t("h4",{attrs:{id:"为什么不是两次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次"}},[_._v("#")]),_._v(" 为什么不是两次？")]),_._v(" "),t("ul",[t("li",[_._v("差别在于最后客户端对服务器的确认。防止已经失效的"),t("code",[_._v("SYN")]),_._v("连接报文请求突然传送至服务器，从而产生错误（服务器端因接收了"),t("strong",[_._v("早已失效的连接请求报文")]),_._v("，从而一直等待客户端请求，最终导致"),t("strong",[_._v("形成死锁、浪费资源")]),_._v("）。")]),_._v(" "),t("li",[_._v("场景描述：客户端发送了第一个"),t("code",[_._v("SYN")]),_._v("请求连接并且没有丢失，只是因为在网络结点中滞留时间较长。此时由于客户端迟迟没有收到 ACK 确认报文，以为服务器没有收到，会重新发送，但是网络通畅时之前的报文又传送过来了，于是客户端和服务器会建立两次连接，造成不必要的错误和资源浪费。而若是三次握手，即使失效报文传至服务器，服务器回复"),t("code",[_._v("ACK")]),_._v("报文，客户端也不会再次确认，于是连接不会再次建立。")])]),_._v(" "),t("h4",{attrs:{id:"为什么不是四次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是四次"}},[_._v("#")]),_._v(" 为什么不是四次？")]),_._v(" "),t("ul",[t("li",[_._v("因为服务器向客户端发送"),t("code",[_._v("ACK")]),_._v("报文和"),t("code",[_._v("SYN")]),_._v("报文的流程可以优化为一次握手。")])]),_._v(" "),t("h3",{attrs:{id:"说说-tcp-四次挥手的过程-为什么是四次而不是三次-等待2msl的意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说-tcp-四次挥手的过程-为什么是四次而不是三次-等待2msl的意义"}},[_._v("#")]),_._v(" 说说 TCP 四次挥手的过程？为什么是四次而不是三次？等待2MSL的意义？")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.3vcr93r4mlm0.png",alt:"image"}})]),_._v(" "),t("h4",{attrs:{id:"四次挥手的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手的过程"}},[_._v("#")]),_._v(" 四次挥手的过程")]),_._v(" "),t("p",[_._v("刚开始双方处于"),t("code",[_._v("ESTABLISHED")]),_._v("状态。")]),_._v(" "),t("ol",[t("li",[_._v("客户端要断开了，向服务器发送 "),t("code",[_._v("FIN")]),_._v(" 报文，发送后客户端变成了"),t("code",[_._v("FIN-WAIT-1")]),_._v("状态。注意, 这时候客户端同时也变成了"),t("code",[_._v("half-close(半关闭)")]),_._v("状态，即无法向服务端发送报文，只能接收。")]),_._v(" "),t("li",[_._v("服务端接收后向客户端发送"),t("code",[_._v("ACK")]),_._v("报文，变成了"),t("code",[_._v("CLOSED-WAIT")]),_._v("状态。客户端接收到了服务端的确认，变成了"),t("code",[_._v("FIN-WAIT2")]),_._v("状态。")]),_._v(" "),t("li",[_._v("服务端向客户端发送"),t("code",[_._v("FIN")]),_._v("，自己进入"),t("code",[_._v("LAST-ACK")]),_._v("状态。")]),_._v(" "),t("li",[_._v("客户端收到服务端发来的"),t("code",[_._v("FIN")]),_._v("后，自己变成了"),t("code",[_._v("TIME-WAIT")]),_._v("状态，然后发送"),t("code",[_._v("ACK")]),_._v("给服务端。然后客户端需要等待足够长的时间，具体来说，是 2 个 "),t("code",[_._v("MSL")]),_._v("("),t("code",[_._v("Maximum Segment Lifetime，报文最大生存时间")]),_._v("), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示"),t("code",[_._v("ACK")]),_._v("成功到达，挥手结束，否则客户端重发"),t("code",[_._v("ACK")]),_._v("。")])]),_._v(" "),t("h4",{attrs:{id:"为什么是四次而不是三次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次而不是三次"}},[_._v("#")]),_._v(" 为什么是四次而不是三次？")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("服务端在接收到"),t("code",[_._v("FIN")]),_._v("， 往往不会立即返回"),t("code",[_._v("FIN")]),_._v("，必须等到服务端所有数据都发送完毕了，才能发"),t("code",[_._v("FIN")]),_._v("。因此先发一个"),t("code",[_._v("ACK")]),_._v("表示已经收到客户端的"),t("code",[_._v("FIN")]),_._v("，延迟一段时间才发"),t("code",[_._v("FIN")]),_._v("。这就造成了四次挥手。")])]),_._v(" "),t("li",[t("p",[_._v("如果是三次挥手，等于说服务端将"),t("code",[_._v("ACK")]),_._v("和"),t("code",[_._v("FIN")]),_._v("的发送合并为一次挥手，这个时候"),t("strong",[_._v("长时间的延迟")]),_._v("可能会导致客户端误以为"),t("code",[_._v("FIN")]),_._v("没有到达客户端，从而让客户端不断的重发"),t("code",[_._v("FIN")]),_._v("。")])])]),_._v(" "),t("h4",{attrs:{id:"等待2msl的意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等待2msl的意义"}},[_._v("#")]),_._v(" 等待2MSL的意义？")]),_._v(" "),t("ul",[t("li",[_._v("假设不等待，如果服务端还有很多数据包要给客户端发，而此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱。")]),_._v(" "),t("li",[_._v("等待"),t("code",[_._v("2MSL")]),_._v("的意义：\n"),t("ul",[t("li",[_._v("1 个"),t("code",[_._v("MSL")]),_._v("确保四次挥手中客户端最后的"),t("code",[_._v("ACK")]),_._v("报文最终能达到服务器端。")]),_._v(" "),t("li",[_._v("1 个"),t("code",[_._v("MSL")]),_._v("确保服务器端没有收到"),t("code",[_._v("ACK")]),_._v("后重传的"),t("code",[_._v("FIN")]),_._v("报文可以到达。")])])])]),_._v(" "),t("h3",{attrs:{id:"tcp-和-udp-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp-的区别"}},[_._v("#")]),_._v(" TCP 和 UDP 的区别？")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("连接")]),_._v("（即，客户端和服务器的连接）：\n"),t("ul",[t("li",[_._v("TCP 面向连接，在双方互相通信之前，TCP 需要三次握手建立连接。")]),_._v(" "),t("li",[_._v("UDP 无连接，即发送数据之前不需要建立连接。")])])]),_._v(" "),t("li",[t("strong",[_._v("安全")]),_._v("：\n"),t("ul",[t("li",[_._v("TCP 提供可靠的服务，传送的数据无差错、不丢失、不重复且按序到达。")]),_._v(" "),t("li",[_._v("UDP 尽最大努力交付，因此不保证可靠。")])])]),_._v(" "),t("li",[t("strong",[_._v("传输效率")]),_._v("：\n"),t("ul",[t("li",[_._v("TCP 传输效率相对较低。")]),_._v(" "),t("li",[_._v("UDP 传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。")])])]),_._v(" "),t("li",[t("strong",[_._v("连接对象数量")]),_._v("：\n"),t("ul",[t("li",[_._v("TCP 连接点对点，一对一。")]),_._v(" "),t("li",[_._v("UDP 连接支持一对一、一对多、多对一和多对多。")])])]),_._v(" "),t("li",[t("strong",[_._v("数据传输形式")]),_._v("：\n"),t("ul",[t("li",[_._v("TCP 基于字节流进行数据传输，将一个个 IP 包变成了字节流。")]),_._v(" "),t("li",[_._v("UDP 的数据传输是基于数据报的，这是因为继承了 IP 层的特性。")])])])]),_._v(" "),t("h3",{attrs:{id:"tcp-如何保证数据的可靠传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-如何保证数据的可靠传输"}},[_._v("#")]),_._v(" TCP 如何保证数据的可靠传输？")]),_._v(" "),t("p",[t("strong",[_._v("（1）校验和")])]),_._v(" "),t("p",[_._v("数据传输过程中，发送的数据段都会当成一个16位的整数，将整数加起来得到校验和。发送方在发送数据前计算校验和，接收方收到数据后对数据使用同样方式计算求出校验和，与发送方的进行比对。")]),_._v(" "),t("p",[t("strong",[_._v("（2）确认应答和序列号")])]),_._v(" "),t("p",[_._v("TCP传输时对每个字节的数据进行编号，即序列号。同时每次接收方收到数据后，都会对传输方发送 ACK 确认应答。")]),_._v(" "),t("p",[t("strong",[_._v("（3）超时重传")])]),_._v(" "),t("p",[_._v("发送数据后等待一段时间没有收到 ACK 报文，将对刚才发送的数据进行重新发送。")]),_._v(" "),t("p",[t("strong",[_._v("（4）连接管理")])]),_._v(" "),t("p",[_._v("三次握手和四次挥手。")]),_._v(" "),t("p",[t("strong",[_._v("（5）流量控制")])]),_._v(" "),t("p",[_._v("TCP根据接收端对数据的处理能力，决定发送方的发送速度。")]),_._v(" "),t("p",[t("strong",[_._v("（6）拥塞控制")])]),_._v(" "),t("p",[_._v("TCP通过维护拥塞窗口实现拥塞控制，窗口会根据当前拥塞情况增大或缩小。")]),_._v(" "),t("h3",{attrs:{id:"流量控制和拥塞控制的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制和拥塞控制的区别"}},[_._v("#")]),_._v(" 流量控制和拥塞控制的区别？")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("流量控制："),t("strong",[_._v("是")]),_._v("端到端")]),_._v("的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收（B缓冲窗口过小或者处理过慢），这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。")]),_._v(" "),t("li",[t("strong",[_._v("拥塞控制："),t("strong",[_._v("是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个")]),_._v("全局性")]),_._v("的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。")])]),_._v(" "),t("h3",{attrs:{id:"如何理解-tcp-的-keepalive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-tcp-的-keepalive"}},[_._v("#")]),_._v(" 如何理解 TCP 的 keepalive？")]),_._v(" "),t("ul",[t("li",[_._v("应用场景：试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。")]),_._v(" "),t("li",[_._v("作用：探测对端的连接有没有失效。")])]),_._v(" "),t("h3",{attrs:{id:"如何理解-http-状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-http-状态码"}},[_._v("#")]),_._v(" 如何理解 HTTP 状态码？")]),_._v(" "),t("p",[_._v("RFC 规定 HTTP 的状态码为"),t("strong",[_._v("三位数")]),_._v("，被分为五类:")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("1xx")]),_._v(": 表示目前是协议处理的中间状态，还需要后续操作。")]),_._v(" "),t("li",[t("strong",[_._v("2xx")]),_._v(": 表示请求成功状态。")]),_._v(" "),t("li",[t("strong",[_._v("3xx")]),_._v(": 重定向状态，资源位置发生变动，需要重新请求。")]),_._v(" "),t("li",[t("strong",[_._v("4xx")]),_._v(": 请求报文有误。")]),_._v(" "),t("li",[t("strong",[_._v("5xx")]),_._v(": 服务器端发生错误。")])]),_._v(" "),t("h4",{attrs:{id:"_1xx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1xx"}},[_._v("#")]),_._v(" 1xx")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("101 Switching Protocols")]),_._v("：在"),t("code",[_._v("HTTP")]),_._v("升级为"),t("code",[_._v("WebSocket")]),_._v("的时候，如果服务器同意变更，就会发送状态码"),t("code",[_._v("101")]),_._v("。")])]),_._v(" "),t("h4",{attrs:{id:"_2xx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2xx"}},[_._v("#")]),_._v(" 2xx")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("200 OK")]),_._v("：见得最多的请求成功状态码。通常在响应体中放有数据。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("204 No Content")]),_._v("：含义与 200 相同，但响应头后没有 body 数据。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("206 Partial Content")]),_._v("：顾名思义，表示部分内容，它的使用场景为"),t("code",[_._v("HTTP")]),_._v("分块下载和断点续传，当然也会带上相应的响应头字段"),t("code",[_._v("Content-Range")]),_._v("。")])])]),_._v(" "),t("h4",{attrs:{id:"_3xx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3xx"}},[_._v("#")]),_._v(" 3xx")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("301 Moved Permanently")]),_._v("：永久重定向，对应着 "),t("strong",[_._v("302 Found")]),_._v("，即临时重定向。")]),_._v(" "),t("blockquote",[t("p",[_._v("比如你的网站从"),t("code",[_._v("HTTP")]),_._v("升级到了"),t("code",[_._v("HTTPS")]),_._v("了，以前的站点再也不用了，应当返回"),t("code",[_._v("301")]),_._v("，这个时候浏览器默认会做"),t("strong",[_._v("缓存优化")]),_._v("，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回"),t("code",[_._v("302")]),_._v("即可，和"),t("code",[_._v("301")]),_._v("不同的是，浏览器并不会做缓存优化。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("304 Not Modified")]),_._v("：当浏览器"),t("strong",[_._v("协商缓存")]),_._v("命中时会返回这个状态码。")])])]),_._v(" "),t("h4",{attrs:{id:"_4xx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4xx"}},[_._v("#")]),_._v(" 4xx")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("400 Bad Request")]),_._v("：开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("403 Forbidden")]),_._v("：这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("404 Not Found")]),_._v("：资源未找到，表示没在服务器上找到相应的资源。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("405 Method Not Allowed")]),_._v("：请求方法不被服务器端允许。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("406 Not Acceptable")]),_._v("：资源无法满足客户端的条件。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("408 Request Timeout")]),_._v("：服务器等待了太长时间。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("409 Conflict")]),_._v("：多个请求发生了冲突。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("413 Request Entity Too Large")]),_._v("：请求体的数据过大。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("414 Request-URI Too Long")]),_._v("：请求行里的 URI 太大。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("429 Too Many Request")]),_._v("：客户端发送的请求过多。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("431 Request Header Fields Too Large")]),_._v("：请求头的字段内容太大。")])])]),_._v(" "),t("h4",{attrs:{id:"_5xx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5xx"}},[_._v("#")]),_._v(" 5xx")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("500 Internal Server Error")]),_._v("：仅仅告诉你服务器出错了，出了啥错咱也不知道。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("501 Not Implemented")]),_._v("：表示客户端请求的功能还不支持。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("502 Bad Gateway")]),_._v("：服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("503 Service Unavailable")]),_._v("：表示服务器当前很忙，暂时无法响应服务。")])])]),_._v(" "),t("h3",{attrs:{id:"http-1-0-1-1-2-0-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-1-1-2-0-的区别"}},[_._v("#")]),_._v(" HTTP 1.0/1.1/2.0 的区别？")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("协议版本")]),_._v(" "),t("th",[_._v("特点")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("HTTP 1.0")]),_._v(" "),t("td",[_._v("无状态、无连接")])]),_._v(" "),t("tr",[t("td",[_._v("HTTP 1.1")]),_._v(" "),t("td",[_._v("1. 长（持久）连接（即在同一个"),t("code",[_._v("TCP")]),_._v("的连接中可传送多个"),t("code",[_._v("HTTP")]),_._v("请求 & 响应）"),t("br"),_._v("2. 请求管道化"),t("br"),_._v("3. 增加缓存处理（新的字段如"),t("code",[_._v("cache-control")]),_._v("）"),t("br"),_._v("4. 增加"),t("code",[_._v("Host")]),_._v("字段、支持断点传输等（把文件分成几部分）")])]),_._v(" "),t("tr",[t("td",[_._v("HTTP 2.0")]),_._v(" "),t("td",[_._v("1. 二进制分帧"),t("br"),_._v("2. 多路复用（或连接共享）"),t("br"),_._v("3. 头部压缩"),t("br"),_._v("4. 服务器推送")])])])]),_._v(" "),t("h3",{attrs:{id:"get-和-post-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[_._v("#")]),_._v(" GET 和 POST 的区别？")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("缓存")]),_._v("：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。")]),_._v(" "),t("li",[t("strong",[_._v("编码")]),_._v("：GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。")]),_._v(" "),t("li",[t("strong",[_._v("参数")]),_._v("：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。")]),_._v(" "),t("li",[t("strong",[_._v("幂等性")]),_._v('：GET 是幂等的，而 POST 不是。("幂等"表示执行相同的操作，结果也是相同的， Get 请求用于对服务器资源不会产生影响。)')]),_._v(" "),t("li",[t("strong",[_._v("TCP")]),_._v("：GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100 (continue)， 然后再发 body 部分。("),t("strong",[_._v("火狐")]),_._v("浏览器除外，它的 POST 请求只发一个 TCP 包。)")])]),_._v(" "),t("h3",{attrs:{id:"http-和-https-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-的区别"}},[_._v("#")]),_._v(" HTTP 和 HTTPS 的区别？")]),_._v(" "),t("ul",[t("li",[_._v("HTTPS 并不是一个新的协议, 它在 HTTP 和 TCP 的传输中建立了一个安全层，利用"),t("strong",[_._v("对称加密")]),_._v("和"),t("strong",[_._v("非对称加密")]),_._v("结合"),t("strong",[_._v("数字证书认证")]),_._v("的方式，让传输过程的安全性大大提高。")])]),_._v(" "),t("p",[_._v("（1）HTTPS 协议用到CA申请证书，而 HTTP 不需要。")]),_._v(" "),t("p",[_._v("（2）HTTP 是超文本传输协议，信息明文传输；HTTPS 是具有安全性的 SSL 加密传输协议。")]),_._v(" "),t("p",[_._v("（3）HTTP 使用80端口，HTTPS 使用443端口。")]),_._v(" "),t("p",[_._v("（4）HTTP 连接简单，是无状态的；HTTPS 是由 TLS/SSL + HTTP 协议构建的可加密传输、身份验证的网络协议，更加安全。")]),_._v(" "),t("ul",[t("li",[_._v("HTTPS相对于HTTP的"),t("strong",[_._v("改进")]),_._v("：增加双向身份认证、使用加密算法保证数据传输安全性、防止报文重放攻击。")])]),_._v(" "),t("h3",{attrs:{id:"https-的加密过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-的加密过程"}},[_._v("#")]),_._v(" HTTPS 的加密过程？")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.70h14kv42600.png",alt:"image"}})]),_._v(" "),t("ol",[t("li",[_._v("客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数 client_random、以及客户端支持的加密方法。")]),_._v(" "),t("li",[_._v("服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的数字证书、以及一个服务器生成的随机数 server_random。")]),_._v(" "),t("li",[_._v("客户端确认服务器证书有效后，生成一个新的随机数 pre_random，并使用数字证书中的"),t("strong",[_._v("公钥")]),_._v("，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。")]),_._v(" "),t("li",[_._v("服务器使用自己的"),t("strong",[_._v("私钥")]),_._v("，来解密客户端发送过来的随机数 pre_random。并提供前面所有内容的 hash 值来供客户端检验。")]),_._v(" "),t("li",[_._v("客户端和服务器端根据约定的加密方法使用前面的三个随机数，即 client_random、server_random、pre_random，生成对话秘钥 secret，以后的对话过程都使用这个秘钥 secret 来加密信息。")])]),_._v(" "),t("h3",{attrs:{id:"https-的加密过程为什么要结合使用对称加密和非对称加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-的加密过程为什么要结合使用对称加密和非对称加密"}},[_._v("#")]),_._v(" HTTPS 的加密过程为什么要结合使用对称加密和非对称加密？")]),_._v(" "),t("ul",[t("li",[_._v("对称加密和非对称加密，单独应用任何一个，都会存在安全隐患。\n"),t("ul",[t("li",[_._v("单独使用对称加密，即 双方使用同一个秘钥对数据进行加密和解密。但秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。")]),_._v(" "),t("li",[_._v("单独使用非对称加密，即 双方分别使用两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。但是服务器的数据只能用私钥进行加密，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的。")])])]),_._v(" "),t("li",[_._v("因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。")])]),_._v(" "),t("h3",{attrs:{id:"https-如何保证数据不被篡改-保证数据的安全性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-如何保证数据不被篡改-保证数据的安全性"}},[_._v("#")]),_._v(" HTTPS 如何保证数据不被篡改（保证数据的安全性）？")]),_._v(" "),t("ul",[t("li",[_._v("HTTPS 在 HTTP 和 TCP 的传输中建立了一个安全层，利用"),t("strong",[_._v("对称加密")]),_._v("和"),t("strong",[_._v("非对称加密")]),_._v("结合"),t("strong",[_._v("数字证书认证")]),_._v("的方式，提高数据传输的安全性。\n"),t("ul",[t("li",[_._v("利用非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加解密。")]),_._v(" "),t("li",[_._v("浏览器拿到数字证书后，如何来对证书进行认证呢？首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 "),t("strong",[_._v("Hash")]),_._v(" 函数，来这个函数来计算明文内容得到"),t("code",[_._v("信息A")]),_._v("，然后用公钥解密明文内容得到"),t("code",[_._v("信息B")]),_._v("，两份信息做比对，一致则表示认证合法。")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);