<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | 前端知识维基</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/img/logo.svg">
    <meta name="description" content="Jamie的个人前端知识库">
    
    <link rel="preload" href="/assets/css/0.styles.495d9abf.css" as="style"><link rel="preload" href="/assets/js/app.58d5b322.js" as="script"><link rel="preload" href="/assets/js/2.d9f8578e.js" as="script"><link rel="preload" href="/assets/js/38.6942e461.js" as="script"><link rel="prefetch" href="/assets/js/10.b22ef15b.js"><link rel="prefetch" href="/assets/js/11.369cb489.js"><link rel="prefetch" href="/assets/js/12.ad7e192f.js"><link rel="prefetch" href="/assets/js/13.4535a34a.js"><link rel="prefetch" href="/assets/js/14.648dc886.js"><link rel="prefetch" href="/assets/js/15.d890679a.js"><link rel="prefetch" href="/assets/js/16.e2660027.js"><link rel="prefetch" href="/assets/js/17.f6bfe71e.js"><link rel="prefetch" href="/assets/js/18.25f6959d.js"><link rel="prefetch" href="/assets/js/19.b4911249.js"><link rel="prefetch" href="/assets/js/20.a2e55b45.js"><link rel="prefetch" href="/assets/js/21.0f16212e.js"><link rel="prefetch" href="/assets/js/22.e1e5db6e.js"><link rel="prefetch" href="/assets/js/23.e91ef8e2.js"><link rel="prefetch" href="/assets/js/24.d6c1629f.js"><link rel="prefetch" href="/assets/js/25.67bfb1d5.js"><link rel="prefetch" href="/assets/js/26.239b92f8.js"><link rel="prefetch" href="/assets/js/27.bc849161.js"><link rel="prefetch" href="/assets/js/28.7e14793f.js"><link rel="prefetch" href="/assets/js/29.adffb486.js"><link rel="prefetch" href="/assets/js/3.639daa35.js"><link rel="prefetch" href="/assets/js/30.1dce4615.js"><link rel="prefetch" href="/assets/js/31.4c81154b.js"><link rel="prefetch" href="/assets/js/32.bde74a75.js"><link rel="prefetch" href="/assets/js/33.c5ee316d.js"><link rel="prefetch" href="/assets/js/34.c62dfccf.js"><link rel="prefetch" href="/assets/js/35.ea8a9888.js"><link rel="prefetch" href="/assets/js/36.06afa074.js"><link rel="prefetch" href="/assets/js/37.11a91269.js"><link rel="prefetch" href="/assets/js/39.620971a1.js"><link rel="prefetch" href="/assets/js/4.1b609518.js"><link rel="prefetch" href="/assets/js/40.52150e02.js"><link rel="prefetch" href="/assets/js/41.fac14e3f.js"><link rel="prefetch" href="/assets/js/42.36d47a73.js"><link rel="prefetch" href="/assets/js/43.e4fe95fc.js"><link rel="prefetch" href="/assets/js/44.3aa1db93.js"><link rel="prefetch" href="/assets/js/45.49f8538e.js"><link rel="prefetch" href="/assets/js/46.51f81eee.js"><link rel="prefetch" href="/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/assets/js/7.f39602d3.js"><link rel="prefetch" href="/assets/js/8.6340730b.js"><link rel="prefetch" href="/assets/js/9.d08c9a59.js">
    <link rel="stylesheet" href="/assets/css/0.styles.495d9abf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识维基</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础" class="mobile-dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic-computer-courses/computer-networks.html" class="nav-link">
  计算机基础知识
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/01-basic/" class="nav-link">
  基础知识
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/02-data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/03-advanced-algorithm/" class="nav-link">
  进阶算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/04-algorithm-design-concept/" class="nav-link">
  算法设计思想
</a></li></ul></div></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试
</a></div><div class="nav-item"><a href="https://blog.csdn.net/qq_40642832" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/jamieshui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础" class="mobile-dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic-computer-courses/computer-networks.html" class="nav-link">
  计算机基础知识
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/01-basic/" class="nav-link">
  基础知识
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/02-data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/03-advanced-algorithm/" class="nav-link">
  进阶算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/04-algorithm-design-concept/" class="nav-link">
  算法设计思想
</a></li></ul></div></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试
</a></div><div class="nav-item"><a href="https://blog.csdn.net/qq_40642832" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/jamieshui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/interview/" aria-current="page" class="sidebar-link">面试常见考点</a></li><li><a href="/interview/01-html.html" class="sidebar-link">HTML</a></li><li><a href="/interview/02-css.html" class="sidebar-link">CSS</a></li><li><a href="/interview/03-javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/interview/04-node.html" class="sidebar-link">Node.js</a></li><li><a href="/interview/05-vue.html" class="sidebar-link">Vue.js</a></li><li><a href="/interview/06-others.html" class="sidebar-link">常用工具</a></li><li><a href="/interview/07-computer-networks.html" aria-current="page" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#目录" class="sidebar-link">目录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#说说-tcp-三次握手的过程-为什么是三次而不是两次、四次" class="sidebar-link">说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#说说-tcp-四次挥手的过程-为什么是四次而不是三次-等待2msl的意义" class="sidebar-link">说说 TCP 四次挥手的过程？为什么是四次而不是三次？等待2MSL的意义？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#tcp-和-udp-的区别" class="sidebar-link">TCP 和 UDP 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#tcp-如何保证数据的可靠传输" class="sidebar-link">TCP 如何保证数据的可靠传输？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#流量控制和拥塞控制的区别" class="sidebar-link">流量控制和拥塞控制的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#如何理解-tcp-的-keepalive" class="sidebar-link">如何理解 TCP 的 keepalive？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#如何理解-http-状态码" class="sidebar-link">如何理解 HTTP 状态码？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#http-1-0-1-1-2-0-的区别" class="sidebar-link">HTTP 1.0/1.1/2.0 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#get-和-post-的区别" class="sidebar-link">GET 和 POST 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#http-和-https-的区别" class="sidebar-link">HTTP 和 HTTPS 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#https-的加密过程" class="sidebar-link">HTTPS 的加密过程？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#https-的加密过程为什么要结合使用对称加密和非对称加密" class="sidebar-link">HTTPS 的加密过程为什么要结合使用对称加密和非对称加密？</a></li><li class="sidebar-sub-header"><a href="/interview/07-computer-networks.html#https-如何保证数据不被篡改-保证数据的安全性" class="sidebar-link">HTTPS 如何保证数据不被篡改（保证数据的安全性）？</a></li></ul></li></ul></li><li><a href="/interview/08-web-browser.html" class="sidebar-link">浏览器</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="计算机网络面试常考知识点"><a href="#计算机网络面试常考知识点" class="header-anchor">#</a> 计算机网络面试常考知识点</h1> <h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <h3 id="说说-tcp-三次握手的过程-为什么是三次而不是两次、四次"><a href="#说说-tcp-三次握手的过程-为什么是三次而不是两次、四次" class="header-anchor">#</a> 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</h3> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.hhsi5d8zrww.png" alt="image"></p> <h4 id="三次握手的过程"><a href="#三次握手的过程" class="header-anchor">#</a> 三次握手的过程</h4> <p>从最开始双方都处于<code>CLOSED</code>状态。然后服务端开始监听某个端口，进入了<code>LISTEN</code>状态。</p> <ol><li>客户端主动发起连接，发送<code>SYN</code> , 自己变成了<code>SYN-SENT</code>状态。</li> <li>服务端接收到，返回<code>SYN</code>和<code>ACK</code>(对应客户端发来的SYN)，自己变成了<code>SYN-REVD</code>。</li> <li>客户端再发送<code>ACK</code>给服务端，自己变成了<code>ESTABLISHED</code>状态；服务端收到<code>ACK</code>之后，也变成了<code>ESTABLISHED</code>状态。</li></ol> <h4 id="为什么不是两次"><a href="#为什么不是两次" class="header-anchor">#</a> 为什么不是两次？</h4> <ul><li>差别在于最后客户端对服务器的确认。防止已经失效的<code>SYN</code>连接报文请求突然传送至服务器，从而产生错误（服务器端因接收了<strong>早已失效的连接请求报文</strong>，从而一直等待客户端请求，最终导致<strong>形成死锁、浪费资源</strong>）。</li> <li>场景描述：客户端发送了第一个<code>SYN</code>请求连接并且没有丢失，只是因为在网络结点中滞留时间较长。此时由于客户端迟迟没有收到 ACK 确认报文，以为服务器没有收到，会重新发送，但是网络通畅时之前的报文又传送过来了，于是客户端和服务器会建立两次连接，造成不必要的错误和资源浪费。而若是三次握手，即使失效报文传至服务器，服务器回复<code>ACK</code>报文，客户端也不会再次确认，于是连接不会再次建立。</li></ul> <h4 id="为什么不是四次"><a href="#为什么不是四次" class="header-anchor">#</a> 为什么不是四次？</h4> <ul><li>因为服务器向客户端发送<code>ACK</code>报文和<code>SYN</code>报文的流程可以优化为一次握手。</li></ul> <h3 id="说说-tcp-四次挥手的过程-为什么是四次而不是三次-等待2msl的意义"><a href="#说说-tcp-四次挥手的过程-为什么是四次而不是三次-等待2msl的意义" class="header-anchor">#</a> 说说 TCP 四次挥手的过程？为什么是四次而不是三次？等待2MSL的意义？</h3> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.3vcr93r4mlm0.png" alt="image"></p> <h4 id="四次挥手的过程"><a href="#四次挥手的过程" class="header-anchor">#</a> 四次挥手的过程</h4> <p>刚开始双方处于<code>ESTABLISHED</code>状态。</p> <ol><li>客户端要断开了，向服务器发送 <code>FIN</code> 报文，发送后客户端变成了<code>FIN-WAIT-1</code>状态。注意, 这时候客户端同时也变成了<code>half-close(半关闭)</code>状态，即无法向服务端发送报文，只能接收。</li> <li>服务端接收后向客户端发送<code>ACK</code>报文，变成了<code>CLOSED-WAIT</code>状态。客户端接收到了服务端的确认，变成了<code>FIN-WAIT2</code>状态。</li> <li>服务端向客户端发送<code>FIN</code>，自己进入<code>LAST-ACK</code>状态。</li> <li>客户端收到服务端发来的<code>FIN</code>后，自己变成了<code>TIME-WAIT</code>状态，然后发送<code>ACK</code>给服务端。然后客户端需要等待足够长的时间，具体来说，是 2 个 <code>MSL</code>(<code>Maximum Segment Lifetime，报文最大生存时间</code>), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示<code>ACK</code>成功到达，挥手结束，否则客户端重发<code>ACK</code>。</li></ol> <h4 id="为什么是四次而不是三次"><a href="#为什么是四次而不是三次" class="header-anchor">#</a> 为什么是四次而不是三次？</h4> <ul><li><p>服务端在接收到<code>FIN</code>， 往往不会立即返回<code>FIN</code>，必须等到服务端所有数据都发送完毕了，才能发<code>FIN</code>。因此先发一个<code>ACK</code>表示已经收到客户端的<code>FIN</code>，延迟一段时间才发<code>FIN</code>。这就造成了四次挥手。</p></li> <li><p>如果是三次挥手，等于说服务端将<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手，这个时候<strong>长时间的延迟</strong>可能会导致客户端误以为<code>FIN</code>没有到达客户端，从而让客户端不断的重发<code>FIN</code>。</p></li></ul> <h4 id="等待2msl的意义"><a href="#等待2msl的意义" class="header-anchor">#</a> 等待2MSL的意义？</h4> <ul><li>假设不等待，如果服务端还有很多数据包要给客户端发，而此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱。</li> <li>等待<code>2MSL</code>的意义：
<ul><li>1 个<code>MSL</code>确保四次挥手中客户端最后的<code>ACK</code>报文最终能达到服务器端。</li> <li>1 个<code>MSL</code>确保服务器端没有收到<code>ACK</code>后重传的<code>FIN</code>报文可以到达。</li></ul></li></ul> <h3 id="tcp-和-udp-的区别"><a href="#tcp-和-udp-的区别" class="header-anchor">#</a> TCP 和 UDP 的区别？</h3> <ul><li><strong>连接</strong>（即，客户端和服务器的连接）：
<ul><li>TCP 面向连接，在双方互相通信之前，TCP 需要三次握手建立连接。</li> <li>UDP 无连接，即发送数据之前不需要建立连接。</li></ul></li> <li><strong>安全</strong>：
<ul><li>TCP 提供可靠的服务，传送的数据无差错、不丢失、不重复且按序到达。</li> <li>UDP 尽最大努力交付，因此不保证可靠。</li></ul></li> <li><strong>传输效率</strong>：
<ul><li>TCP 传输效率相对较低。</li> <li>UDP 传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。</li></ul></li> <li><strong>连接对象数量</strong>：
<ul><li>TCP 连接点对点，一对一。</li> <li>UDP 连接支持一对一、一对多、多对一和多对多。</li></ul></li> <li><strong>数据传输形式</strong>：
<ul><li>TCP 基于字节流进行数据传输，将一个个 IP 包变成了字节流。</li> <li>UDP 的数据传输是基于数据报的，这是因为继承了 IP 层的特性。</li></ul></li></ul> <h3 id="tcp-如何保证数据的可靠传输"><a href="#tcp-如何保证数据的可靠传输" class="header-anchor">#</a> TCP 如何保证数据的可靠传输？</h3> <p><strong>（1）校验和</strong></p> <p>数据传输过程中，发送的数据段都会当成一个16位的整数，将整数加起来得到校验和。发送方在发送数据前计算校验和，接收方收到数据后对数据使用同样方式计算求出校验和，与发送方的进行比对。</p> <p><strong>（2）确认应答和序列号</strong></p> <p>TCP传输时对每个字节的数据进行编号，即序列号。同时每次接收方收到数据后，都会对传输方发送 ACK 确认应答。</p> <p><strong>（3）超时重传</strong></p> <p>发送数据后等待一段时间没有收到 ACK 报文，将对刚才发送的数据进行重新发送。</p> <p><strong>（4）连接管理</strong></p> <p>三次握手和四次挥手。</p> <p><strong>（5）流量控制</strong></p> <p>TCP根据接收端对数据的处理能力，决定发送方的发送速度。</p> <p><strong>（6）拥塞控制</strong></p> <p>TCP通过维护拥塞窗口实现拥塞控制，窗口会根据当前拥塞情况增大或缩小。</p> <h3 id="流量控制和拥塞控制的区别"><a href="#流量控制和拥塞控制的区别" class="header-anchor">#</a> 流量控制和拥塞控制的区别？</h3> <ul><li><strong>流量控制：<strong>是</strong>端到端</strong>的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收（B缓冲窗口过小或者处理过慢），这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。</li> <li><strong>拥塞控制：<strong>是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个</strong>全局性</strong>的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</li></ul> <h3 id="如何理解-tcp-的-keepalive"><a href="#如何理解-tcp-的-keepalive" class="header-anchor">#</a> 如何理解 TCP 的 keepalive？</h3> <ul><li>应用场景：试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。</li> <li>作用：探测对端的连接有没有失效。</li></ul> <h3 id="如何理解-http-状态码"><a href="#如何理解-http-状态码" class="header-anchor">#</a> 如何理解 HTTP 状态码？</h3> <p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p> <ul><li><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</li> <li><strong>2xx</strong>: 表示请求成功状态。</li> <li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</li> <li><strong>4xx</strong>: 请求报文有误。</li> <li><strong>5xx</strong>: 服务器端发生错误。</li></ul> <h4 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1xx</h4> <ul><li><strong>101 Switching Protocols</strong>：在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码<code>101</code>。</li></ul> <h4 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2xx</h4> <ul><li><p><strong>200 OK</strong>：见得最多的请求成功状态码。通常在响应体中放有数据。</p></li> <li><p><strong>204 No Content</strong>：含义与 200 相同，但响应头后没有 body 数据。</p></li> <li><p><strong>206 Partial Content</strong>：顾名思义，表示部分内容，它的使用场景为<code>HTTP</code>分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</p></li></ul> <h4 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3xx</h4> <ul><li><p><strong>301 Moved Permanently</strong>：永久重定向，对应着 <strong>302 Found</strong>，即临时重定向。</p> <blockquote><p>比如你的网站从<code>HTTP</code>升级到了<code>HTTPS</code>了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做<strong>缓存优化</strong>，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，浏览器并不会做缓存优化。</p></blockquote></li> <li><p><strong>304 Not Modified</strong>：当浏览器<strong>协商缓存</strong>命中时会返回这个状态码。</p></li></ul> <h4 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4xx</h4> <ul><li><p><strong>400 Bad Request</strong>：开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p></li> <li><p><strong>403 Forbidden</strong>：这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p></li> <li><p><strong>404 Not Found</strong>：资源未找到，表示没在服务器上找到相应的资源。</p></li> <li><p><strong>405 Method Not Allowed</strong>：请求方法不被服务器端允许。</p></li> <li><p><strong>406 Not Acceptable</strong>：资源无法满足客户端的条件。</p></li> <li><p><strong>408 Request Timeout</strong>：服务器等待了太长时间。</p></li> <li><p><strong>409 Conflict</strong>：多个请求发生了冲突。</p></li> <li><p><strong>413 Request Entity Too Large</strong>：请求体的数据过大。</p></li> <li><p><strong>414 Request-URI Too Long</strong>：请求行里的 URI 太大。</p></li> <li><p><strong>429 Too Many Request</strong>：客户端发送的请求过多。</p></li> <li><p><strong>431 Request Header Fields Too Large</strong>：请求头的字段内容太大。</p></li></ul> <h4 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5xx</h4> <ul><li><p><strong>500 Internal Server Error</strong>：仅仅告诉你服务器出错了，出了啥错咱也不知道。</p></li> <li><p><strong>501 Not Implemented</strong>：表示客户端请求的功能还不支持。</p></li> <li><p><strong>502 Bad Gateway</strong>：服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p></li> <li><p><strong>503 Service Unavailable</strong>：表示服务器当前很忙，暂时无法响应服务。</p></li></ul> <h3 id="http-1-0-1-1-2-0-的区别"><a href="#http-1-0-1-1-2-0-的区别" class="header-anchor">#</a> HTTP 1.0/1.1/2.0 的区别？</h3> <table><thead><tr><th>协议版本</th> <th>特点</th></tr></thead> <tbody><tr><td>HTTP 1.0</td> <td>无状态、无连接</td></tr> <tr><td>HTTP 1.1</td> <td>1. 长（持久）连接（即在同一个<code>TCP</code>的连接中可传送多个<code>HTTP</code>请求 &amp; 响应）<br>2. 请求管道化<br>3. 增加缓存处理（新的字段如<code>cache-control</code>）<br>4. 增加<code>Host</code>字段、支持断点传输等（把文件分成几部分）</td></tr> <tr><td>HTTP 2.0</td> <td>1. 二进制分帧<br>2. 多路复用（或连接共享）<br>3. 头部压缩<br>4. 服务器推送</td></tr></tbody></table> <h3 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> GET 和 POST 的区别？</h3> <ul><li><strong>缓存</strong>：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li> <li><strong>编码</strong>：GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li> <li><strong>参数</strong>：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li> <li><strong>幂等性</strong>：GET 是幂等的，而 POST 不是。(&quot;幂等&quot;表示执行相同的操作，结果也是相同的， Get 请求用于对服务器资源不会产生影响。)</li> <li><strong>TCP</strong>：GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100 (continue)， 然后再发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包。)</li></ul> <h3 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="header-anchor">#</a> HTTP 和 HTTPS 的区别？</h3> <ul><li>HTTPS 并不是一个新的协议, 它在 HTTP 和 TCP 的传输中建立了一个安全层，利用<strong>对称加密</strong>和<strong>非对称加密</strong>结合<strong>数字证书认证</strong>的方式，让传输过程的安全性大大提高。</li></ul> <p>（1）HTTPS 协议用到CA申请证书，而 HTTP 不需要。</p> <p>（2）HTTP 是超文本传输协议，信息明文传输；HTTPS 是具有安全性的 SSL 加密传输协议。</p> <p>（3）HTTP 使用80端口，HTTPS 使用443端口。</p> <p>（4）HTTP 连接简单，是无状态的；HTTPS 是由 TLS/SSL + HTTP 协议构建的可加密传输、身份验证的网络协议，更加安全。</p> <ul><li>HTTPS相对于HTTP的<strong>改进</strong>：增加双向身份认证、使用加密算法保证数据传输安全性、防止报文重放攻击。</li></ul> <h3 id="https-的加密过程"><a href="#https-的加密过程" class="header-anchor">#</a> HTTPS 的加密过程？</h3> <p><img src="https://cdn.jsdelivr.net/gh/jamieshui/image-hosting@master/picx-image-hosting/image.70h14kv42600.png" alt="image"></p> <ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数 client_random、以及客户端支持的加密方法。</li> <li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的数字证书、以及一个服务器生成的随机数 server_random。</li> <li>客户端确认服务器证书有效后，生成一个新的随机数 pre_random，并使用数字证书中的<strong>公钥</strong>，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li> <li>服务器使用自己的<strong>私钥</strong>，来解密客户端发送过来的随机数 pre_random。并提供前面所有内容的 hash 值来供客户端检验。</li> <li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，即 client_random、server_random、pre_random，生成对话秘钥 secret，以后的对话过程都使用这个秘钥 secret 来加密信息。</li></ol> <h3 id="https-的加密过程为什么要结合使用对称加密和非对称加密"><a href="#https-的加密过程为什么要结合使用对称加密和非对称加密" class="header-anchor">#</a> HTTPS 的加密过程为什么要结合使用对称加密和非对称加密？</h3> <ul><li>对称加密和非对称加密，单独应用任何一个，都会存在安全隐患。
<ul><li>单独使用对称加密，即 双方使用同一个秘钥对数据进行加密和解密。但秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。</li> <li>单独使用非对称加密，即 双方分别使用两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。但是服务器的数据只能用私钥进行加密，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的。</li></ul></li> <li>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。</li></ul> <h3 id="https-如何保证数据不被篡改-保证数据的安全性"><a href="#https-如何保证数据不被篡改-保证数据的安全性" class="header-anchor">#</a> HTTPS 如何保证数据不被篡改（保证数据的安全性）？</h3> <ul><li>HTTPS 在 HTTP 和 TCP 的传输中建立了一个安全层，利用<strong>对称加密</strong>和<strong>非对称加密</strong>结合<strong>数字证书认证</strong>的方式，提高数据传输的安全性。
<ul><li>利用非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加解密。</li> <li>浏览器拿到数字证书后，如何来对证书进行认证呢？首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 <strong>Hash</strong> 函数，来这个函数来计算明文内容得到<code>信息A</code>，然后用公钥解密明文内容得到<code>信息B</code>，两份信息做比对，一致则表示认证合法。</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview/06-others.html" class="prev">
        常用工具
      </a></span> <span class="next"><a href="/interview/08-web-browser.html">
        浏览器
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.58d5b322.js" defer></script><script src="/assets/js/2.d9f8578e.js" defer></script><script src="/assets/js/38.6942e461.js" defer></script>
  </body>
</html>
